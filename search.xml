<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>neovim配置</title>
      <link href="/neovim-pei-zhi/"/>
      <url>/neovim-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="安装neovim"><a href="#安装neovim" class="headerlink" title="安装neovim"></a>安装neovim</h2><p>这里有个小坑，如果直接使用apt install下载，下载的会是一个旧版的neovim，0.2的样子</p><p>需要从 <a href="https://github.com/neovim/neovim/releases/tag/stable">官网</a> 下载 <a href="https://github.com/neovim/neovim/releases/download/stable/nvim-linux64.tar.gz">nvim-linux64.tar.gz</a>，因为我这里Windows 11用的wsl2，所以可以直接下到windows里，然后通过mnt文件夹把windows的文件移过来。</p><p>解压缩后，在文件目录的bin目录下有个nvim的可执行文件。我选择把文件夹放到 /usr/local 里面。<br>由于wsl2与windows共用一套环境变量，因此最好是避开设置nvim的环境变量，以防冲突以及环境变量过多。</p><p>我这里是这样做的，给nvim脚本的路径取了个别名，写在 .zshrc（如果不知道这个是什么的看我之前终端配置的博客） 里。</p><p>我在 .zshrc 后面加上的几行取别名的命令如下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">alias</span> <span class="token assign-left variable">nvim</span><span class="token operator">=</span>/usr/local/nvim/bin/nvim<span class="token builtin class-name">alias</span> <span class="token assign-left variable">vim</span><span class="token operator">=</span>nvim<span class="token builtin class-name">alias</span> <span class="token assign-left variable">v</span><span class="token operator">=</span>vim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样我只要打 “v 文件名”，就可以直接进行编辑了，如果你觉得不太好，可以省去后面两行，然后 “nvim 文件名”</p><h2 id="安装lazyvim"><a href="#安装lazyvim" class="headerlink" title="安装lazyvim"></a>安装lazyvim</h2><p>使用 <a href="https://www.lazyvim.org/">lazyvim</a> 进行包管理，去<a href="https://www.lazyvim.org/installation">这里</a>按照说明一步步安装即可</p><p>先安装 Nerd Font，在终端里设置字体，不安装这个很多小图标用不了。主机是windows，就在windows下ttf文件装好先，记得装windows compatible的。</p><p>安装 <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>，一个好用的正则搜索工具<br>安装 <a href="https://github.com/sharkdp/fd">fd</a>，文件系统查找工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ripgrep fd-find<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装LSP"><a href="#安装LSP" class="headerlink" title="安装LSP"></a>安装LSP</h2><p>即 <strong>Language Server Protocol</strong>，这个需要额外安装对应语言的。</p><p>如果需要安装这个，还得安装一下 npm，否则Mason下载不了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> nodejs <span class="token function">npm</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春招总结与反思</title>
      <link href="/chun-zhao-zong-jie-yu-fan-si/"/>
      <url>/chun-zhao-zong-jie-yu-fan-si/</url>
      
        <content type="html"><![CDATA[<p>今年春招真的不是一般的难受，各种双9（本硕均985）大佬也是各种简历挂，一面挂，啥ACM金牌银牌大佬，本科发操作系统顶会SCI的大佬，在今年也很难找到大厂的实习，如果能找到一个基本马上就签了。</p><p>注：写这篇博客时心情不是很好，如果冒犯了你，不是故意的。</p><p>个人感觉问题主要出在两个地方</p><ul><li><strong>疫情刚结束，经济还没完全恢复</strong>。各大公司岗位缩减很多，有很多人能力确实是很强的，潜力也更大，但是公司不愿意再花时间培养了，更喜欢有多段实习，项目实操能力强的。</li><li><strong>学校以及实验室不会特意往一个专业技能方向培养学生，而企业需要这种人</strong>。你仔细回想下，大学的老师，辅导员往往会鼓励学生参加数学竞赛，英语竞赛，程序设计竞赛，数学建模等等，也会鼓励学生保研，考研，获取更高的学历。但我想说的是，这些在私企招人面前，全部都可以归结成“<strong>幼儿园的大红花</strong>”之流（国企的话，学历与绩点还是很有用的，认识的学历比较高，能力一般的，最后往往还是去了国企）。因为这些东西并不能真正提高你某个技能方向的实际能力。如果要就业，面对一个技能方向，这些人往往还是要重新学，而这就导致了找不到工作。这并不是理论的推测，而是我身边一个又一个鲜活的案例所表明的现实。</li></ul><p>那么在今年这种环境下，本科还能找到班上的有什么特征呢？</p><ul><li><strong>大一就选定了技术方向，并且一直搞下去</strong>。没有在提升所谓核心能力的事上花太多时间，而把很多时间花到了解决实际问题，做实际项目上。</li><li><strong>计算机基础非常扎实</strong>。现在只是临时背一下所谓的八股文已经完全不够用了，如果没有结合实际项目中的深度理解，很快就会被面试官问倒。很多技术大佬就是倒在这一块。国内现在大环境就非常浮躁，一堆人搞的项目吹的牛比飞天，一问个常见的简单问题就和一啥比一样，我求求你们真的别再好高骛远了好吗？踏实一点。</li><li><strong>大二就有去大厂实习过</strong>。当然，22年找实习是比23年好找的。今年简直地狱级别难度。一段大厂的实习经历，胜过无数花里胡哨的奖项。</li><li><strong>擅长分析定位问题，并反思改进</strong>。找工作，项目是必不可少的。但是很多人项目其实都是半抄半写，缺乏自己的思考。这里为什么要用这个，为什么不用那个，用那个会不会更好？性能还能提升嘛？性能好是怎么体现出来的？有测试过嘛？怎么测试的？测试的方法是正确的？行业通用的测试就是对的嘛？还能改进测试方法吗？当用户数量变多，这个项目如何扩展？只有把这些问题都想明白了，都解决了，才算真正地搞成了一个项目。</li><li><strong>懂得扬长避短</strong>。简历写的好这些自然不用提。他们还会引导面试官往自己擅长的地方去问。有些人真的别和一个啥比（就是我）一样了，觉得技术岗就要高冷沉默，踏实干事。就因为技术岗很多东西都很抽象，你的表达能力才更要强。东西写出来是技术强，但是面试不能清晰地给面试官表达，有什么鸟用？！</li><li><strong>人脉强</strong>。这点不用说，懂得都懂，不懂的说了也不懂，这里面牵扯到的太多，有各方利益的因素。因此，我才说懂得都懂。</li></ul><p>为什么我不能找到大厂实习？</p><p>结合上面分析的能找到班上的人的特点，我的不足有以下几点。</p><ul><li><strong>项目经验不足</strong>。做的项目都比较小，都是玩具型的。要么就是在别人大项目的基础上稍微改改。项目缺乏思考，没有融入自己的深入思考。大型项目的实际开发经验不足。</li><li><strong>专业方向不明确</strong>。大学搞的方向太杂了，比如Unity游戏开发，Java后端，Python爬虫，前端，数据分析，直到后面才发现自己最喜欢也最擅长的还是偏底层的开发，比如C++服务器开发。而这时已经比别人晚很多了。</li><li><strong>专业方向技术不够强</strong>。虽然核心能力（编程能力）还可以，但是没有意识到专业方向技术的重要性。只有专业方向的技术才能真正使你找到工作。</li><li><strong>计算机基础不扎实</strong>。只是八股背得还行，然后C++ 11 ~ 17的特性比较清楚，其他的基础知识没有结合实际项目，实际API（linux操作系统API，网络编程API）去更深入地理解。</li><li><strong>表达能力沟通能力不强</strong>。在面试官面前不能把自己心里想的东西很好地讲出来，语言逻辑不强。面对别人的提问，不能立刻抓住问题核心。</li><li><strong>没有重视信息的重要性。</strong>在信息错综复杂的今天，有价值的信息是比金子还重要的东西。然而很多人（包括我）不愿在信息获取上花时间。为了得到某些信息，花上几十，几百，甚至几千去询问一些内部大佬是非常值得的。这些信息类似于，考研的往年题，院校内部情况，公司内部HC数量，公司内部氛围等等。而且不要只信于一人，起码得有三方一致。</li></ul><p>解决方案：</p><ul><li><strong>立刻考研</strong>。以<strong>考上</strong>为第一目标，211及以上都行，绝对不浪费过多时间在无意义的应试上。从今年来看，学历对于私企确实不算很重要，211基本所有大厂的简历关就没啥问题了（简历过不了是内部没HC，或者自己问题）。</li><li><strong>考上研立刻深入学习项目开发的东西</strong>。</li><li><strong>大四暑期实习，研一暑期实习，研二继续实习。</strong>大四的实习尽量找吧，反正要尽早接触企业开发环境。</li><li><strong>后续还有中厂的面试就继续面</strong>。锻炼沟通表达能力。但是不继续投简历了。</li></ul><p>后续：实习进超聚变了，感觉还行，不考研了😄😄</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣趣题集</title>
      <link href="/li-kou-qu-ti-ji/"/>
      <url>/li-kou-qu-ti-ji/</url>
      
        <content type="html"><![CDATA[<p>本文长期更新，记录力扣碰到的一些趣题<br><a href="https://leetcode.cn/u/cutecaidd/">我的力扣主页</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="多边形三角剖分的最低得分"><a href="#多边形三角剖分的最低得分" class="headerlink" title="多边形三角剖分的最低得分"></a><a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/">多边形三角剖分的最低得分</a></h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给你一个凸 $n$ 边形，要你把它全部分成三角形，每个三角形的得分为三个顶点数字的乘积，求该图形最低总得分</p><p>例子：下图的最低总得分即为13</p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/shape3.jpg"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这题虽然不难，但是转换还是挺巧妙的，将图形的一条边当作区间DP中的区间，边左右侧的图形又形成新的图形继续分割。选取分割点，就是给一条边已有的两个点选剩下的一个点组成三角形，再加上左右图形的得分就是选取当前分割点的总得分，那么DP使其最小即可。这里选用记忆化搜索形式来写，代码更加简单。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minScoreTriangulation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> v<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token decorator annotation punctuation">@cache</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> l <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> r<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>            <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span>v<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">*</span> v<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">*</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dfs<span class="token punctuation">(</span>l<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="子数组中占绝大多数的元素"><a href="#子数组中占绝大多数的元素" class="headerlink" title="子数组中占绝大多数的元素"></a><a href="https://leetcode.cn/problems/online-majority-element-in-subarray/">子数组中占绝大多数的元素</a></h3><h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一个数组，每次查询数组某个区间出现 <code>threshold</code> 次数或次数以上的元素，保证 <code>threshold</code> 大于区间长度的一半。</p><p>区间长度与查询次数都是 $10^4$ 的量级</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>用数据结构的话，直接权值线段树维护 + 摩尔投票就好了。但这么无趣的做法，肯定上不了这篇博客。</p><p>反过来思考，如果该区间存在一个数出现次数大于等于 <code>threshold</code> ，那么我们在该区间随便选一个数，是目标数的概率大于 50%，这是多么高的概率！</p><p>因此可以直接随机化选数一定次数，每次通过二分判断该数在当前区间出现次数是否大于 <code>threshold</code> 。如果满足直接返回。如果随机化选取结束后还没有，就假定不存在这样的数。</p><p>参考<a href="https://leetcode.cn/problems/online-majority-element-in-subarray/solution/suiji-by-981377660lmt-fw82/">🍓大佬</a></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MajorityChecker</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>arr <span class="token operator">=</span> arr        self<span class="token punctuation">.</span>indexes <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">list</span><span class="token punctuation">)</span>          <span class="token keyword">for</span> i<span class="token punctuation">,</span> num <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">query</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> left<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> right<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> threshold<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        ROUND <span class="token operator">=</span> <span class="token number">20</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>ROUND<span class="token punctuation">)</span><span class="token punctuation">:</span>            index <span class="token operator">=</span> randint<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>            num <span class="token operator">=</span> self<span class="token punctuation">.</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span>            count <span class="token operator">=</span> bisect_right<span class="token punctuation">(</span>self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">-</span> bisect_left<span class="token punctuation">(</span>self<span class="token punctuation">.</span>indexes<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">,</span> left<span class="token punctuation">)</span>            <span class="token keyword">if</span> count <span class="token operator">&gt;=</span> threshold<span class="token punctuation">:</span> <span class="token keyword">return</span> num        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 程序设计竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inet_ntoa与线程安全</title>
      <link href="/inet-ntoa-yu-xian-cheng-an-quan/"/>
      <url>/inet-ntoa-yu-xian-cheng-an-quan/</url>
      
        <content type="html"><![CDATA[<p>之前在《Linux高性能服务器编程》中就有学习到 inet_ntoa 函数不可重入。</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230401151114.png"></p><p>并且用程序验证了下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">struct</span> <span class="token class-name">in_addr</span> addr1<span class="token punctuation">,</span> addr2<span class="token punctuation">;</span>  addr1<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token string">"192.180.2.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  addr2<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span><span class="token string">"211.179.3.2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> s1 <span class="token operator">=</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> s2 <span class="token operator">=</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p %s\n"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p %s\n"</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p>0x7f34cabfa510 211.179.3.2<br>0x7f34cabfa510 211.179.3.2</p><p>所以易验证其不可重入性</p><p>然而今天 clang-tidy 给了我一个 warning</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230401151942.png"></p><p>这似乎合情合理，因为其内部只有一个静态缓冲区，多个线程可能会重复覆盖，但真的如此吗？</p><p>（注：posix 标准规定 stdio 函数均为原子的，故 printf 不用同步，不会像 cout 一样混乱）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">struct</span> <span class="token class-name">in_addr</span> addr<span class="token punctuation">;</span>  addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> s <span class="token operator">=</span> <span class="token function">inet_ntoa</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p %s\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">work1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"192.180.2.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">work2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"211.179.3.2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>thread <span class="token function">x1</span><span class="token punctuation">(</span>work1<span class="token punctuation">)</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>thread <span class="token function">x2</span><span class="token punctuation">(</span>work2<span class="token punctuation">)</span><span class="token punctuation">;</span>  x1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  x2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p>0x7f7aaf10d6b0 192.180.2.1<br>0x7f7aae90c6b0 211.179.3.2</p><p>发现，貌似 inet_ntoa 是线程安全的？</p><p>小扒 gnu c library 源码看一看</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230401161255.png"></p><p>于是发现了个 __thread 关键字。</p><p>__thread是GCC内置的线程局部存储设施。__thread 变量每一个线程有一份独立实体，各个线程的值互不干扰。可以用来修饰那些带有全局性且值可能变，但是又不值得用全局变量保护的变量。</p><p>看来和 C++11 的 thread_local 差不多</p><p>所以可以暂且认为其是线程安全的</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++智能指针</title>
      <link href="/c-zhi-neng-zhi-zhen/"/>
      <url>/c-zhi-neng-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<p>前几天米哈游一面，面试官很帅，很温柔，问的也很基础，不过有些会结合场景进行追问。由于是第一次面试，整个人都挺紧张，感觉基础确实还是不扎实，有些很基础但没怎么用到过的东西就没太关注。这篇文章总结下面试遇到的C++智能指针问题。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>智能指针主要有 <code>unique_ptr</code>，<code>shared_ptr</code>，<code>weak_ptr</code>。<code>auto_ptr</code> 是在 C++ 11 之前作为智能指针实验品发明出来，但由于其违反人直觉的特性（后面会补充提到），在C++11提出右值引用与移动语义后，其已被弃用。</p><p>个人认为智能指针是对C++ RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization，资源获取即初始化）的一种极佳实践。RAII要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配（获取），同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"create class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// // std::unique_ptr&lt;A&gt; a(new A); 这种写法不推荐，后续会讲到</span>  <span class="token keyword">auto</span> a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token operator">-&gt;</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p>create class A<br>class A<br>delete class A</p><p>可见除了可以自动管理资源以外，就和一个普通的指针的用法差不多。不过，如同unique的含义一样，unique_ptr显式删除了拷贝构造函数与赋值运算符，以保证资源被独立管理。如果想要将一个unique的资源给另一个，则只能使用<strong>移动语义</strong>来<strong>转移</strong>资源。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> b <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，智能指针里面有一些通用的函数，但是个人感觉那些函数其实都有打破指针管理的倾向，应当少用，初始化完后当成普通指针用是最好的。</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"create class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">auto</span> a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> <span class="token function">b</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p>create class A<br>delete class A</p><p>可见shared_ptr就是在内部只保留了一个对象，当指向一个对象的所有shared_ptr全部析构，对象资源才会被释放。其内部是使用引用计数实现的。需要说明的是，shared_ptr的引用计数是线程安全的，用了原子类型。</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230318213018.png"></p><p>可见当 <code>_Sp_counted_base</code> 模板类型为 <code>_S_atomic</code>  时，引用计数的增加使用CAS（compare and swap）原语（一般是指<strong>由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断</strong>）。CAS大致是这样操作的，将预期值和内存地址的实际值比较，若不相等，则用内存地址的实际值替换预期值，并根据预期值重新计算修改值。当发现预期值和内存地址的实际值相等后，则用修改值替换内存地址实际值，此时CAS原语操作成功。而失败后重新尝试的过程被称为<strong>自旋</strong>。这是乐观锁的一种，其适用于临界区比较小、并发量比较低的情况。当临界区比较大、并发量比较高时，用互斥锁为更好的选择。</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230318213221.png"></p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230321193134.png"></p><p>而从上图可以看到，默认的模板类型便是  <code>_S_atomic</code> ，因此 shared_ptr 内部的引用计数是线程安全的。</p><h4 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h4><p>但是，当两个类互相存有指向对方的shared_ptr时，析构时会导致引用计数均为1，双方的资源都无法释放。</p><p>如下所示</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> pb<span class="token punctuation">;</span>  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"create class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> pa<span class="token punctuation">;</span>  <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"create class B\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete class B\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">auto</span> a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> b <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token operator">-&gt;</span>pb <span class="token operator">=</span> b<span class="token punctuation">;</span>  b<span class="token operator">-&gt;</span>pa <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p>create class A<br>create class B</p><p>可见析构函数并没有并没有被调用。这个问题需要用后面说到的weak_ptr解决。</p><h4 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h4><p>当一个对象需要从内部获取一个指向自己的 <code>std::shared_ptr</code> 时，很容易想到一种方法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">&gt;</span> <span class="token function">getPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Test<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但若该对象已经被一组共享指针指向，这样返回便会重新创建一组共享指针。这样，最后析构时便会对Test对象进行两次delete，发生错误。</p><p>这种错误可以通过在类中保存一个 weak_ptr 成员来避免，也可以使用标准库的enable_shared_from_this解决。</p><p>标准库提供了一种使用 CRTP(<strong>C</strong>uriously <strong>R</strong>ecurring <strong>T</strong>emplate <strong>P</strong>attern) 方法的基类来避免这个问题，大致如下使用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Test</span> <span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Test</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Test<span class="token operator">&gt;</span> <span class="token function">getPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个类继承自 <code>enable_shared_from_this</code> 时，这个类的实例在创建时，会额外分配一个 <code>weak_ptr</code> 类型的数据成员 <code>_weak_this</code>，用来记录一个弱引用（weak reference）指向自身。同时，<code>enable_shared_from_this</code> 还提供了一个 <code>shared_from_this()</code> 方法，用来返回一个指向自身的 <code>shared_ptr</code>。</p><p>当调用 <code>shared_from_this()</code> 方法时，它会先检查 <code>_weak_this</code> 是否已经被初始化，如果没有被初始化，就抛出一个 <code>std::bad_weak_ptr</code> 异常。否则，它会返回一个指向自身的 <code>shared_ptr</code>，这个 <code>shared_ptr</code> 的计数器会与所有其他指向该对象的 <code>shared_ptr</code> 共享一个计数器。</p><p><code>enable_shared_from_this</code> 的一个常见用法是在实现异步操作的回调函数中。在这种情况下，需要将一个回调函数绑定到一个异步操作中，并且当异步操作完成时，需要调用回调函数并将某些数据传递给它。如果回调函数需要访问异步操作所使用的对象，就可以使用 <code>enable_shared_from_this</code> 来获取一个指向该对象的 <code>std::shared_ptr</code>。</p><p>另一个使用场景是在对象之间建立弱引用（weak reference）。通过 <code>std::weak_ptr</code> 可以实现对被管理对象的引用，但需要先将其与 <code>std::shared_ptr</code> 绑定。而通过 <code>enable_shared_from_this</code> 可以方便地获取一个 <code>std::shared_ptr</code>，从而避免手动维护 <code>std::shared_ptr</code> 的引用计数和生命周期。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><code>std::weak_ptr</code> 用来表达临时所有权的概念：当某个对象只有存在时才需要被访问，而且随时可能被他人删除时，可以使用 <code>std::weak_ptr</code> 来跟踪该对象。需要获得临时所有权时，则将其转换为 <code>std::shared_ptr</code>，此时如果原来的 <code>std::shared_ptr</code> 被销毁，则该对象的生命期将被延长至这个临时的 <code>std::shared_ptr</code> 同样被销毁为止。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"create class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> gw<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"use_count == "</span> <span class="token operator">&lt;&lt;</span> gw<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> spt <span class="token operator">=</span> gw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 使用之前必须复制到 shared_ptr</span>    spt<span class="token operator">-&gt;</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"gw is expired\n"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">{</span>    <span class="token keyword">auto</span> sp <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    gw <span class="token operator">=</span> sp<span class="token punctuation">;</span>    <span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p>create class A<br>use_count == 1: class A<br>delete class A<br>use_count == 0: gw is expired</p><p><code>std::weak_ptr</code> 的另一用法是打断 <code>std::shared_ptr</code> 所管理的对象组成的环状引用。若这种环被孤立（例如无指向环中的外部共享指针），则 <code>shared_ptr</code> 引用计数无法抵达零，而内存被泄露。能令环中的指针之一为弱指针以避免此情况。</p><p>上面<code>shared_ptr</code>循环引用的例子这样修改后，便可以正常释放资源</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> pb<span class="token punctuation">;</span>  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"create class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete class A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> pa<span class="token punctuation">;</span>  <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"create class B\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"delete class B\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">auto</span> a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">auto</span> b <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token operator">-&gt;</span>pb <span class="token operator">=</span> b<span class="token punctuation">;</span>  b<span class="token operator">-&gt;</span>pa <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p>create class A<br>create class B<br>delete class A<br>delete class B</p><h2 id="智能指针的创建"><a href="#智能指针的创建" class="headerlink" title="智能指针的创建"></a>智能指针的创建</h2><p>《Effective Modern C++》中的条款 21有写到：优先使用 std::make_unique 和 std::make_shared 而不是直接使用new，在上面的所有代码的示例中，我也都遵守了这一条款。那么，为什么要这样呢？</p><h3 id="一、避免代码重复"><a href="#一、避免代码重复" class="headerlink" title="一、避免代码重复"></a>一、避免代码重复</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>VeryLongClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span>VeryLongClass<span class="token operator">&gt;</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token keyword">new</span> VeryLongClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自行体会</p><h3 id="二、保证异常安全"><a href="#二、保证异常安全" class="headerlink" title="二、保证异常安全"></a>二、保证异常安全</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span> spw<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>考虑上面的代码，如果有一个计算 <code>priority</code>的函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，下面这段代码就有可能内存泄露</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为进入 <code>processWidget</code>  前，包含三步操作</p><p>执行new Widget，执行computePriority，执行std::shared_ptr的构造函数</p><p>但这三步顺序是不一定的，如果 <code>computePriority</code>  先执行，那么当其发生异常，就无事发生。</p><p>但是如果执行顺序上面所列的顺序一样，那么当 <code>computePriority</code> 发生异常，那么new出来的Widget就会发生内存泄露，因为它永远不会存储在Step 3中产生的本应负责管理它 的 std::shared_ptr 中。</p><p>而如果使用make_shared，如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>computePriority<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>便不会有内存泄露的风险。在runtime的时候， std::make_shared 或者computePriority都有可能被第一次调用。如果是 std::make_shared 先被调用，被动态分配的Widget安全的存储在返回的 std::shared_ptr 中 (在computePriority被调用之前)。如果computePriority产生了异常， std::shared_ptr 的析构函数会负责把它所拥有的Widget回收。如果computePriority首先被调用并且产生出一个异常， std::make_shared 不会被调用，因此也不必担心动态分配的Widget会产生泄漏的问题。</p><h3 id="三、提升效率"><a href="#三、提升效率" class="headerlink" title="三、提升效率"></a>三、提升效率</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>很明显的情况是代码只需一次内存分配，但实际上它执行了两次。每一个 std::shared_ptr，都指向了一个包含被指向对象的引用计数的控制块，控制块的分配工作在 std::shared_ptr 的构造函数内部完成。直接使用new，就需要一次为Widget分配内存，第二次需要为控制块分配内存。</p><p>如果使用的是 std::make_shared</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> spw <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一次分配足够了。这是因为std::make_shared分配了一整块空间，包含了Widget对象和控制块。这个优化减少了程序的静态大小，因为代码中只包含了一次分配调用，并且加快了代码的执行速度，因为内存只被分配一次。此外，使用std::make_shared 避免了在控制块中额外添加的一些记录信息的需要，潜在的减少了程序所需的总内存消耗。</p><p>当然，make之类的函数也有一定的缺陷，比如不支持指定自定义的deleter。</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><p>深入理解一样东西最好的办法，就是实现它。</p><h3 id="unique-ptr-1"><a href="#unique-ptr-1" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">unique_ptr</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">explicit</span> <span class="token function">unique_ptr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">unique_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>  unique_ptr <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_ptr <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>  T <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>  T <span class="token operator">*</span><span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>  T <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>  T <span class="token operator">*</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    T <span class="token operator">*</span>ptr <span class="token operator">=</span> ptr_<span class="token punctuation">;</span>    ptr_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">private</span><span class="token operator">:</span>  T <span class="token operator">*</span>ptr_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，<code>unique_ptr</code> 包含一个指向 T 类型对象的指针 _ptr。它的构造函数可以接受一个指针作为参数，并将其包装在 <code>unique_ptr</code> 对象中。在析构函数中，它会自动调用 delete 操作来销毁对象。同时，为了防止拷贝和赋值，我们禁止了 <code>unique_ptr</code> 的拷贝构造函数和赋值操作符。为了让 <code>unique_ptr</code> 用起来更加方便，我们还重载了 operator* 和 operator-&gt; 运算符，以及提供了 get() 和 release() 方法。</p><h3 id="shared-ptr-1"><a href="#shared-ptr-1" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">RefCounter</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">explicit</span> <span class="token function">RefCounter</span><span class="token punctuation">(</span>T <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">count_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">RefCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>count_<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token operator">--</span>count_<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count_ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_ <span class="token operator">?</span> count_ <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  T <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">private</span><span class="token operator">:</span>  T <span class="token operator">*</span>ptr_<span class="token punctuation">;</span>  <span class="token keyword">int</span> count_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">explicit</span> <span class="token function">shared_ptr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">counter_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token generic-function"><span class="token function">RefCounter</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">counter_</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>counter_<span class="token punctuation">)</span> <span class="token punctuation">{</span>    counter_<span class="token operator">-&gt;</span><span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> counter_<span class="token operator">-&gt;</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> counter_<span class="token operator">-&gt;</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  T <span class="token operator">*</span><span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> counter_<span class="token operator">-&gt;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  T <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>counter_<span class="token operator">-&gt;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">private</span><span class="token operator">:</span>  RefCounter<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>counter_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心点在于引用计数的实现，而只有一个类的话，其自身是无法完成的，需要借助于一个计数类</p><p><code>use_count</code> 方法返回当前指针指向的对象被多少指针共享</p><h3 id="weak-ptr-1"><a href="#weak-ptr-1" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">weak_ptr</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">RefCounter</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">explicit</span> <span class="token function">RefCounter</span><span class="token punctuation">(</span>T <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">count_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weak_count_</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>count_<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>count_ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>weak_count_ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">weak_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>weak_count_ <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">add_weak_reference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>weak_count_<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_ <span class="token operator">?</span> count_ <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  T <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">private</span><span class="token operator">:</span>  T <span class="token operator">*</span>ptr_<span class="token punctuation">;</span>  <span class="token keyword">int</span> count_<span class="token punctuation">;</span>  <span class="token keyword">int</span> weak_count_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">shared_ptr</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">explicit</span> <span class="token function">shared_ptr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">counter_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token generic-function"><span class="token function">RefCounter</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">counter_</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>counter_<span class="token punctuation">)</span> <span class="token punctuation">{</span>    counter_<span class="token operator">-&gt;</span><span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> weak_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">counter_</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>counter_<span class="token punctuation">)</span> <span class="token punctuation">{</span>    counter_<span class="token operator">-&gt;</span><span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">shared_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> counter_<span class="token operator">-&gt;</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> counter_<span class="token operator">-&gt;</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  T <span class="token operator">*</span><span class="token keyword">operator</span><span class="token operator">-&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> counter_<span class="token operator">-&gt;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  T <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>counter_<span class="token operator">-&gt;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">private</span><span class="token operator">:</span>  RefCounter<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>counter_<span class="token punctuation">;</span>  <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">weak_ptr</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">weak_ptr</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">weak_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">counter_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">explicit</span> <span class="token function">weak_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>sp<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">counter_</span><span class="token punctuation">(</span>sp<span class="token punctuation">.</span>counter_<span class="token punctuation">)</span> <span class="token punctuation">{</span>    counter_<span class="token operator">-&gt;</span><span class="token function">add_weak_reference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token operator">~</span><span class="token function">weak_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> counter_<span class="token operator">-&gt;</span><span class="token function">weak_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">[</span><span class="token punctuation">[</span>nodiscard<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">bool</span> <span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> counter_ <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">or</span> counter_<span class="token operator">-&gt;</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">private</span><span class="token operator">:</span>  RefCounter<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>counter_<span class="token punctuation">;</span>  <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">shared_ptr</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>weak_ptr</code> 类包含一个指向对象的裸指针 <code>ptr_</code> 和一个指向计数器对象的指针 <code>counter_</code>。同时，它还包含了 <code>lock()</code> 方法和 <code>expired()</code> 方法。</p><p><code>lock()</code> 方法用于将 <code>weak_ptr</code> 转换为一个 <code>shared_ptr</code> 对象，如果指向对象的 <code>shared_ptr</code> 已经失效，返回一个空的 <code>shared_ptr</code>。</p><p><code>expired()</code> 方法用于判断指向的 <code>shared_ptr</code> 对象是否已经失效。如果 <code>counter_</code> 指针为空或者计数器对象的引用计数已经为零，则表示指向的 <code>shared_ptr</code> 对象已经失效。</p><p>需要注意的是，<code>weak_ptr</code> 必须与 <code>shared_ptr</code> 共用同一个计数器对象，因此在构造函数中需要将 <code>shared_ptr</code> 对象的指针和计数器对象的指针都保存下来。</p><p>此处标准库实现是采取一个强计数与一个弱计数，强计数为0则释放资源，弱计数为0则析构计数类。</p><h2 id="弃用的auto-ptr"><a href="#弃用的auto-ptr" class="headerlink" title="弃用的auto_ptr"></a>弃用的auto_ptr</h2><p>从失败中吸取教训，才能够成功。auto_ptr便是C++委员会吸取的一次教训。</p><p>它的想法和unique_ptr一样，就是用来独立地管理内存。但是在C++11之前，还没有移动语义和右值引用。那是怎样实现独立管理内存的呢？</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230320200952.png"></p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230320201053.png"></p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230320201118.png"></p><p>上面这些玩意在一起，就会达成这样一个效果。当你写下如下语句时</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto_ptr<span class="token operator">&lt;</span>mother<span class="token operator">&gt;</span> a<span class="token punctuation">;</span><span class="token keyword">auto</span> <span class="token function">b</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> c<span class="token punctuation">;</span>c <span class="token operator">=</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>你 <code>a</code> 和 <code>b</code> 的 mother 就没了！！！！</p><p><code>auto b(a); </code> 这个代码，a将对象所有权转移给了b，自己置空了。</p><p><code>c = b;</code> 这个代码，b将对象所有权转移给了c，自己置空了。</p><p>但这还不是最狠的，看下面的代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>auto_ptr<span class="token operator">&lt;</span>mother<span class="token operator">&gt;&gt;</span> a<span class="token punctuation">;</span>  <span class="token comment">// ...Some code to input a</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>auto_ptr<span class="token operator">&lt;</span>mother<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>A<span class="token punctuation">,</span> auto_ptr<span class="token operator">&lt;</span>mother<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>B<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> A<span class="token operator">-&gt;</span>a <span class="token operator">&lt;</span> B<span class="token operator">-&gt;</span>a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一趟排序下来，由于内部的swap操作，很多指针的 mother 都没了！！！！！</p><p>因此，在C++11中，为了完善类型系统，使语法更加优雅，使值的传递更加高效，减少拷贝等等，引入了伟大的右值引用与移动语义！！！</p><p>现在 swap 是这样实现的</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230320204941.png"></p><p>而 auto_ptr 也被更换成了 unique_ptr。到此，auto_ptr的历史就结束了。</p><h2 id="罕见的用法"><a href="#罕见的用法" class="headerlink" title="罕见的用法"></a>罕见的用法</h2><p>前面都是管理单个对象，其实智能指针还能管理数组对象</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230320205547.png"></p><p>这样子用的话，ptr 的模板类型是这个</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230320205626.png"></p><p>有些人可能会觉得这为什么会罕见呢？呃，可能是因为有了vector了。反正我很少在实际项目中看到。</p><h2 id="个人的理解"><a href="#个人的理解" class="headerlink" title="个人的理解"></a>个人的理解</h2><p>unique_ptr 经过编译器优化以后是完全零开销的，可以放心大胆地使用它来管理资源。</p><p>但 shared_ptr 其内部的原子计数对于性能是有一定的影响的，而其解决方案enable_shared_from_this用例下，基于shared_ptr的解决方案也并非是非侵入式的。并且，其还具有传播性，当在一个地方使用后，传入传出其他地方，往往又需要shared_ptr（否则对象资源释放会不正确），最后整个项目便到处是shared_ptr。所以使用时一定要小心，要少用。</p><p>那么如何减少shared_ptr的使用呢？其实仔细检视一下整个异步流程，有些资源虽然会先后被不同的对象所引用，但在其整个生存周期内，每一时刻都只有一个对象持有该资源的引用。用于数据收发的缓冲区对象就是一个典型。它们总是被从某个源头产生，然后便一直从一处被传递到另一处，最终在某个时刻被回收。</p><p>对于这样的对象，实际上没有必要针对流程中的每一次所有权转移都进行引用计数操作，只要简单地在分配时将引用计数置1，在需要释放时再将引用计数归零便可以了。</p><p>参考：</p><p>chatGPT</p><p>cppreference</p><p><a href="https://mp.weixin.qq.com/s/deG0GHRpz4Qgq4cLSiW6-g">《C++ 共享指针四宗罪》</a></p><p>《Effective Modern C++》</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端美化: zsh</title>
      <link href="/linux-zhong-duan-mei-hua-zsh/"/>
      <url>/linux-zhong-duan-mei-hua-zsh/</url>
      
        <content type="html"><![CDATA[<p>今天学C++协程时，偶然发现视频里的终端很炫，非常符合我对科技的想象，稍微搜了下，找到了zsh</p><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="安装-zsh"><a href="#安装-zsh" class="headerlink" title="安装 zsh"></a>安装 zsh</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">zsh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是只下载一个裸的zsh，配置很难，所以有人把配置整合了</p><h3 id="安装-Oh-My-Zsh"><a href="#安装-Oh-My-Zsh" class="headerlink" title="安装 Oh My Zsh"></a>安装 Oh My Zsh</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h3><p>可以在这<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes">里面</a>选自己喜欢的主题</p><p>我选的是 <code>jonathan</code></p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230315130512.png" alt="图片"></p><p>选好后，在用户目录下的 <code>.zshrc</code> 文件中，修改这一行即可</p><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230315130949.png"></p><p>然后重启终端就生效啦！</p><p>zsh还对许多常用命令进行了简写，可以使用 <code>alias</code> 命令来查看</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存对齐</title>
      <link href="/nei-cun-dui-qi/"/>
      <url>/nei-cun-dui-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>举个简单的例子：（环境：64位Windows 11，GCC，C++20，O3优化）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A1</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> a<span class="token punctuation">;</span>  <span class="token keyword">int</span> b<span class="token punctuation">;</span>  <span class="token keyword">char</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">A2</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> a<span class="token punctuation">;</span>  <span class="token keyword">char</span> b<span class="token punctuation">;</span>  <span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>A2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token comment">// 12 8</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么两个结构体明明有同样的内容，却有不同大小的内存呢？因为内存对齐！</p><h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><p>1、没有#pragma pack宏的对齐规则</p><ul><li>结构体的起始存储位置必须是能够被该结构体中最大的数据类型所整除。</li><li>每个数据成员存储的起始位置是自身大小的整数倍（比如int在64位机为4字节，则int型成员要从4的整数倍地址开始存储）。</li><li>结构体总大小（也就是sizeof的结果），必须是该结构体成员中最大的对齐模数的整数倍。若不满足，会根据需要自动填充空缺的字节。</li><li>结构体包含另一个结构体成员，则被包含的结构体成员要从其原始结构体内部最大对齐模数的整数倍地址开始存储。（比如struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储。)</li><li>结构体包含数组成员，比如char a[3]，它的对齐方式和分别写3个char是一样的，也就是说它还是按一个字节对齐。如果写：typedef char Array[3]，Array这种类型的对齐方式还是按一个字节对齐，而不是按它的长度3对齐。</li><li>结构体包含共用体成员，则该共用体成员要从其原始共用体内部最大对齐模数的整数倍地址开始存储。</li></ul><p>2、存在#pragma pack宏的对齐</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span>    </span><span class="token comment">//编译器将按照n个字节对齐  </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>     </span><span class="token comment">//取消自定义字节对齐方式</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么对齐规则就变成下面的</p><ul><li>结构，联合，或者类的数据成员，第一个放在偏移为0的地方，以后每个数据成员的对齐，按照#pragma pack指定的数值和自身对齐模数中较小的那个。</li></ul><hr><p>回到上面的程序，按照上述规则，两个结构体都按照最大的数据类型int的 4 字节对齐。第一个结构体，char占1字节，由于接下来是int类型的四个字节，所以会填充为4字节，int过后又有一个char，再次被填充4字节，总共 4 + 4 + 4 = 12 字节。第二个结构体，两个char占2字节，后跟一个int，于是被填充为4字节，总共 4 + 4 = 8 字节。</p><p>这很对，但这东西到底有什么用？</p><h2 id="内存对齐的作用"><a href="#内存对齐的作用" class="headerlink" title="内存对齐的作用"></a>内存对齐的作用</h2><p>内存对齐在实际开发中有很多用途，以下是其中一些：</p><ol><li>提高程序效率：内存对齐可以使变量存储在自然边界上，从而提高 CPU 访问内存的效率，从而提高程序的效率。</li><li>保证内存安全：当结构体或类中的成员变量按照对齐规则进行分配时，可以确保数据不会因为字节对齐而出现错误的偏移量，从而保证内存的安全性。</li><li>节省内存空间：通过内存对齐，可以使变量的存储更加紧凑，减少内存碎片，从而节省内存空间。</li><li>优化缓存行访问：现代 CPU 采用了缓存行的概念，内存对齐可以让变量存储在相邻的缓存行中，从而提高 CPU 访问缓存的效率。</li><li>改善并行处理效率：内存对齐可以改善多线程并发处理时的效率，因为当多个线程访问同一内存时，内存对齐可以减少线程之间的冲突，从而提高并行处理效率。</li><li>确保兼容性：不同编译器或操作系统可能有不同的内存对齐规则，因此在开发中遵循正确的内存对齐规则可以确保程序的兼容性和可移植性。</li></ol><p>自定义网络通讯协议包通常都是定义成struct的形式， 而struct会自动内存对齐，这会造成结构体成员间有”空洞“，传给其它平台后，其它平台弄不清楚原平台是按什么方式对齐的，只会按自己的方式解包。 解出来的结果有可能是错误的。为防止这种情况出现，自定义通讯协议时，一定要让结构体（或联合）成员间都按1来对齐。</p><p>总之，内存对齐是一种重要的技术，它在实际开发中可以优化程序性能、提高程序安全性、节省内存空间等，因此开发人员需要深入理解内存对齐的原理和规则，并根据实际情况进行合理的内存对齐</p><h2 id="内存对齐与位域"><a href="#内存对齐与位域" class="headerlink" title="内存对齐与位域"></a>内存对齐与位域</h2><p>位域是一种控制内存二进制位的技术</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token keyword">uint16_t</span> a <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">uint16_t</span> b <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token keyword">uint16_t</span> c <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// sizeof(A) == 2;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上便可指定a占用1bit（bit不是byte！），b 5bit，c 3 bit</p><p>位域的对齐规则如下：</p><ul><li><p>当相邻位域成员的类型相同时，如果它们的位宽之和小于类型大小，那么后面的成员紧邻前一个成员存储；如果它们的位宽之和大于类型大小，那么后面的成员将存在下一个类型大小的空间</p></li><li><p>如果相邻的位域的数据类型不相同，则不同编译器实现不一样，有些编译器选择不压缩</p></li><li><p>如果位域不连续，中间含非位域，则按标准数据类型大小划分，比如</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>　　<span class="token keyword">uint16_t</span> a <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>　　<span class="token keyword">int</span> b<span class="token punctuation">;</span>　　<span class="token keyword">uint16_t</span> c <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// sizeof(A) == 12;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>对于第一个位域对齐规则再举个例子</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bitset&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token keyword">uint16_t</span> a <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">uint16_t</span> b <span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token keyword">uint16_t</span> c <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">union</span> <span class="token punctuation">{</span>  A a<span class="token punctuation">;</span>  <span class="token keyword">uint16_t</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span> op<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  op<span class="token punctuation">.</span>a<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  op<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  op<span class="token punctuation">.</span>a<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 输出 b 的二进制表示</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">bitset</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">16</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>op<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// 0000000001000011</span>  op<span class="token punctuation">.</span>a<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">bitset</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">16</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>op<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// 0000000001000010</span>  op<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">bitset</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">16</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>op<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// 0000000001000000</span>  op<span class="token punctuation">.</span>a<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">bitset</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">16</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>op<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// 0000000000000000</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-11-alignas说明符"><a href="#C-11-alignas说明符" class="headerlink" title="C++11 alignas说明符"></a>C++11 alignas说明符</h2><p>该说明符可以接受类型或者常量表达式。特别需要注意的是，该常量表达式计算的结果必须是一个2的幂值，否则是无法通过编译的。具体用法如下（这里采用GCC 编译器，因为其alignof可以查看变量的对齐字节长度）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> a1<span class="token punctuation">;</span>  <span class="token keyword">int</span> a2<span class="token punctuation">;</span>  <span class="token keyword">double</span> a3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">X1</span> <span class="token punctuation">{</span>  <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token keyword">char</span> a1<span class="token punctuation">;</span>  <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token keyword">int</span> a2<span class="token punctuation">;</span>  <span class="token keyword">double</span> a3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> X2 <span class="token punctuation">{</span>  <span class="token keyword">char</span> a1<span class="token punctuation">;</span>  <span class="token keyword">int</span> a2<span class="token punctuation">;</span>  <span class="token keyword">double</span> a3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> X3 <span class="token punctuation">{</span>  <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">char</span> a1<span class="token punctuation">;</span>  <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token keyword">int</span> a2<span class="token punctuation">;</span>  <span class="token keyword">double</span> a3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">COUT_ALIGN</span><span class="token expression"><span class="token punctuation">(</span>s<span class="token punctuation">)</span>                                                          </span><span class="token punctuation">\</span>  <span class="token expression">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> </span><span class="token string">"alignof("</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">s</span> </span></span><span class="token string">") = "</span> <span class="token expression"><span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">COUT_SIZE</span><span class="token expression"><span class="token punctuation">(</span>s<span class="token punctuation">)</span>                                                          </span><span class="token punctuation">\</span>  <span class="token expression">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> </span><span class="token string">"sizeof("</span> <span class="token expression"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">s</span> </span></span><span class="token string">") = "</span> <span class="token expression"><span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  X x<span class="token punctuation">;</span>  X1 x1<span class="token punctuation">;</span>  X2 x2<span class="token punctuation">;</span>  X3 x3<span class="token punctuation">;</span>  <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> X3 x4<span class="token punctuation">;</span>  <span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 8</span>  <span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 16</span>  <span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 16</span>  <span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 16</span>  <span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4</span>  <span class="token function">COUT_ALIGN</span><span class="token punctuation">(</span>x4<span class="token punctuation">.</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>  <span class="token function">COUT_SIZE</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 16</span>  <span class="token function">COUT_SIZE</span><span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 32</span>  <span class="token function">COUT_SIZE</span><span class="token punctuation">(</span>x2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 16</span>  <span class="token function">COUT_SIZE</span><span class="token punctuation">(</span>x3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 32</span>  <span class="token function">COUT_SIZE</span><span class="token punctuation">(</span>x4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 32</span>  <span class="token function">COUT_SIZE</span><span class="token punctuation">(</span>x4<span class="token punctuation">.</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在例子中，X的类型对齐字节长度为8字节，而X2在使用了alignas(16)之后，对齐字节长度修改为了16字节。<br>另外， 如果修改结构体成员的对齐字节长度，那么结构体本身的对齐字节长度也会发生变化，因为结构体类型的对齐字节长度总是需要大于或者等于其成员变量类型的对齐字节长度。<br>比如X1的成员变量a1类型的对齐字节长度修改为了16字节，所有X1类型也被修改为16字节对齐。<br>同样的规则也适用于结构体X3，X3类型的对齐字节长度被指定为16字节，虽然其成员变量a1的类型对齐字节长度被指定为8字节，但是并不能改变X3类型的对齐字节长度。<br>最后要说明的是，结构体类型的对齐字节长度，并不能影响声明变量时变量的对齐字节长度，比如x4。<br>不过在变量声明时指定对齐字节长度，也不影响变量内部成员变量类型的对齐字节长度，比如x4.a1。上面的代码用结构体作为例子，实际上对于类也是一样的。</p><p>参考：<br>chatGPT</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统编程入门</title>
      <link href="/linux-xi-tong-bian-cheng-ru-men/"/>
      <url>/linux-xi-tong-bian-cheng-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="简易环境搭建"><a href="#简易环境搭建" class="headerlink" title="简易环境搭建"></a>简易环境搭建</h2><p>本地</p><ul><li>下载 vmware</li><li>从官网下载 20.04LTS 镜像（长期维护版），安装虚拟机，100G空间，4G内存，2核（本地 win11，1T，16G，4核）</li><li>下载 ssh，复制 id_rsa.pub 公钥文件</li></ul><p>虚拟机</p><ul><li>安装 gcc，g++，ssh，gdb，make，<code>sudo apt install gcc g++ ssh gdb make</code></li><li>创建 ssh 公私钥，<code>ssh-keygen</code></li><li>复制之前的公钥到 authorized_keys文件，若没有则创建该文件</li><li>ifconfig 查看 ip 地址</li></ul><p>本地</p><ul><li>下载vscode，在remote管理设置里，以之前 ip 地址创建远程连接</li><li>登录虚拟机</li><li>下载 C++ 全家桶插件，中文插件，文件显示美化插件</li></ul><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>编译 C 文件，尽量使用 gcc 命令，编译 C++ 文件，尽量使用 g++</p><p>gcc 不能自动和 C++ 使用的库链接，g++ 统一当作 C++ 编译，语法检查更严，故尽量用对应命令编译</p><table><thead><tr><th>gcc编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>预处理指定的源文件，不进行编译</td></tr><tr><td>-S</td><td>编译指定的源文件,但是不进行汇编</td></tr><tr><td>-c</td><td>编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td>-o</td><td>-o file1 file2 或 file2 -o file1 将文件 file2 编译成可执行文件 file1</td></tr><tr><td>-I</td><td>指定include包含文件的搜索目录</td></tr><tr><td>-g</td><td>在编译的时候，生成调试信息，该程序可以被调试器调试</td></tr><tr><td>-D</td><td>在程序编译的时候，指定一个宏</td></tr><tr><td>-w</td><td>不生成任何警告信息</td></tr><tr><td>-Wall</td><td>生成所有警告信息</td></tr><tr><td>-On</td><td>n的取值范围:0~3。编译器的优化选项的4个级别,-o0表示没有优化，-o1为缺省值，-o3优化级别最高</td></tr><tr><td>-l</td><td>在程序编译的时候，指定使用的库</td></tr><tr><td>-L</td><td>指定编译的时候，搜索的库的路径</td></tr><tr><td>-fPIC/-fpic</td><td>生成与位置无关的代码</td></tr><tr><td>-shared</td><td>生成共享目标文件,通常用在建立共享库时</td></tr><tr><td>-std</td><td>指定c方言，如:-std=c99,gcc默认的方言是GNU c</td></tr></tbody></table><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中</p><p>动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中</p><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><h4 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h4><p><code>ar rcs libxxx.a ...</code> 使用 .o 文件创建一个名为xxx的静态库</p><p>r —— 将文件插入备存文件中<br>c —— 建立备存文件<br>s —— 索引</p><p>扩展名在 linux 下是 .a ，windows 下 .lib</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230123154729.png"></p><p>对于该示例，可以使用命令 <code>gcc main.c -o app -I ./include/ -l calc -L ./lib</code> 来将静态库编译进来</p><p>表示在 <code>./include</code> 目录下搜寻头文件，链接名为 <code>calc</code> 的库，在 <code>./lib</code> 下搜寻库</p><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>程序启动之后，动态库会被动态加载到内存中，通过ldd (list dynamicdependencies）命令检查动态库依赖关系</p><p><strong>动态库的定位</strong>（linux系统）：</p><p>对于elf格式的可执行文件，由 ld-linux.so 完成链接，路径为</p><p><strong>DT_RPATH段 -&gt; 环境变量 LD_LIBRARY_PATH -&gt; /etc/ld.so.cache 文件列表 -&gt; /lib/，/usr/lib</strong></p><p><strong>环境变量</strong>：</p><p>全局在 <strong>/etc/profile</strong> 修改，用户在 <strong>~/.bashrc</strong>，用户与全局相同的环境变量会覆盖</p><p>一个变量可以对应多个值，多个值以 ：隔开，寻找时依次寻找</p><p>创建环境变量可用在上述两个文件中写export命令，并source使之生效，比如 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:绝对路径</code></p><p>不用export定义的变量只对该shell有效，对子shell也是无效的</p><p>如果只在某个终端写export命令，则环境变量是临时的</p><h4 id="制作-1"><a href="#制作-1" class="headerlink" title="制作"></a>制作</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -c -fpic/fPIC a.c b.cgcc -shared a.o b.o -o libcalc.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>-fpic/fPIC 生成位置无关的文件</p><p>-shared 生成共享库，以动态链接</p><p>如果链接的可执行文件的GOT大小超过计算机特定的最大大小，则会从链接器收到错误消息，指示-fpic不起作用。在这种情况下，请使用-fPIC重新编译。GOT大小根据操作系统的不同而大小不一样。因此尽量使用-fPIC编译</p><p>扩展名在 linux 下是 .a ，windows 下 .dll</p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p><img src="https://caidd-1305545187.cos.ap-nanjing.myqcloud.com/20230123194629.png"></p><p>示例：</p><p><code>gcc main.c -o main -I include/ -L lib/ -l calc</code></p><p>而后由之前所说有三种方法：</p><p>第一种：</p><p>然后在之前说的两个文件夹添加环境变量地址即可，并使用source使之生效</p><p><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/caidd/linux/test/lib</code></p><p>该命令表示，保持原始环境变量的内容，在其后添加一个变量，即库文件夹位置</p><p>第二种：</p><p>修改 /etc/ld.so.conf 文件，直接将目标库的文件夹绝对位置复制到最后即可</p><p>然后使用 sudo ldconfig 使之生效</p><p>第三种：</p><p>将库放到 /lib/，/usr/lib 里面，便会自动找到，但由于会引起命名冲突，所以不推荐</p><h3 id="静态库与动态库对比"><a href="#静态库与动态库对比" class="headerlink" title="静态库与动态库对比"></a>静态库与动态库对比</h3><p>静态库：</p><p>优点</p><ul><li>静态库被打包到应用程序中加载速度快</li><li>发布程序无需提供静态库，移植方便</li></ul><p>缺点</p><ul><li>消耗系统资源,浪费内存</li><li>更新、部暑、发布麻烦</li></ul><p>动态库：</p><p>优点</p><ul><li>可以实现进程间资源共享(共享库)更新、部署、发布简单</li><li>可以控制何时加载动态库</li></ul><p>缺点</p><ul><li>加载速度比静态库慢</li><li>发布程序时需要提供依赖的动态库</li></ul><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p><a href="https://seisman.github.io/how-to-write-makefile/index.html">自己学</a>，后续会接触到的cmake，xmake，主要用于生成 makefile 文件。这些东西都是用于处理大型项目的依赖关系。</p><p>Makefile 不仅使得项目编译更为轻松，还能使编译速度更快，其会自动比对文件的修改时间，只有当目标文件不存在或依赖文件的更新时间晚于目标文件才会进行更新。</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>生成可调试执行程序，gcc，g++ 需要加上 -g 参数，才能在原始程序添加符号表，使得 gdb 能够进行调试</p><p><strong>启动和退出</strong><br>gdb 可执行程序名字<br>quit 退出</p><p><strong>给程序设置参数/获取设置参数</strong></p><p>set args 10 20<br>show args</p><p><strong>GDB使用帮助</strong></p><p>help</p><p><strong>查看当前文件代码</strong></p><p>list/l （从默认位置显示）</p><p>list/l 行号 （以指定行号为中心进行显示）</p><p>list/l 函数名 （从指定的函数显示）</p><p><strong>查看非当前文件代码</strong></p><p>list/l 文件名:行号 </p><p>list/l 文件名:函数名</p><p><strong>设置与查看显示的行数</strong></p><p>show list/listsize</p><p>set list/listsize 行数</p><p><strong>设置断点</strong></p><p>b/break 行号</p><p>b/break 函数名</p><p>b/break 文件名:行号</p><p>b/break 文件名:函数</p><p><strong>查看断点</strong></p><p>i/info b/break</p><p><strong>删除断点</strong></p><p>d/del/delete 断点编号</p><p><strong>设置断点无效</strong></p><p>dis/disable 断点编号</p><p><strong>设置断点生效</strong></p><p>ena/enable 断点编号</p><p><strong>设置条件断点（一般用在循环的位置）</strong></p><p>b/break 10 if i == 5</p><p><strong>运行GDB程序</strong></p><p>start（程序停在第一行）</p><p>run（遇到断点才停）</p><p><strong>继续运行，到下一个断点停</strong></p><p>c/continue</p><p><strong>向下执行一行代码（不会进入函数体）</strong></p><p>n/next</p><p><strong>变量操作</strong></p><p>p/print  变量名（打印变量值）</p><p>ptype 变量名（打印变量类型）</p><p><strong>向下单步调试（遇到函数进入函数体）</strong></p><p>s/step</p><p>finish（跳出函数体）</p><p><strong>自动变量操作</strong></p><p>display num（自动打印指定变量的值）</p><p>i/info display</p><p>undisplay 编号</p><p><strong>其他操作</strong></p><p>set var 变量名 = 变量值</p><p>untill （跳出循环，跳出循环的条件是循环内部没有断点，并且在循环语句内）</p><p><strong>多进程调试</strong></p><p>set folllow-fork-mode [parent（默认） | child] 设置调试父进程或者子进程</p><p>set detach-on-fork [on l off] 设置调试模式</p><p>默认为on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候．其它进程被GDB挂起。</p><p>info inferiors 查看调试的进程</p><p>inferior id 切换当前调试的进程</p><p>detach inferiors id 使进程脱离GDB调试</p><p><strong>Core dump 分析</strong><br><a href="https://www.cnblogs.com/bodhitree/p/5850212.html">gdb core模式</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++浮点数问题</title>
      <link href="/cpp-fu-dian-shu-wen-ti/"/>
      <url>/cpp-fu-dian-shu-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>今天下午遇到这样<a href="https://codeforces.com/contest/1737/problem/B">一道题</a>，被卡了精度，联想起以前比赛时被卡精度的题，以及计算计组成原理的IEEE浮点数标准。故在此进行总结</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://raw.githubusercontent.com/caiddd/picture/main/32-64.jpg"></p><p>在不同的计算机，不同的编译器中，常用的 <code>int</code>, <code>double</code>, <code>long long</code> 类型存储大小基本不变，但是 <code>long double</code> 变化却很多，可偏偏这种数据类型在卡精度时又很常用，所以有必要好好分析一下。</p><p>在C的标准中，仅规定 <code>long double</code> 的精度范围大于等于 <code>double</code></p><p>在 msvc（即VS使用的编译器）中， <code>long double</code> 等同于 <code>double</code> ，都是8个字节</p><blockquote><p>  The<code>long double</code> type is identical to the double type.</p></blockquote><p>而在 gcc 中两者是不同的</p><p>32位下<code>long double</code> 是12个字节, 64位下是16个字节.</p><p><img src="https://raw.githubusercontent.com/caiddd/picture/main/20221008150707.png"></p><p>现今竞赛环境多为64位机 G++/GCC，即 <code>long double</code> 占用了16个字节，128位。</p><p>然而实际编译时，由于x86架构上 fpu 的存在，大部分编译器将 <code>long double</code> 编译成80位的浮点数，用科学计数法的话，其尾数部分是64位。剩下的部分主要用于内存对齐，防止存取的麻烦以及内存空间碎片化。</p><p>也就是说，尾数部分刚好存得下一个 <code>long long</code> ，不会损失精度。</p><p>然而，<code>double</code> 尾数部分就没有那么大了</p><p><img src="https://raw.githubusercontent.com/caiddd/picture/main/20221008152931.png"></p><p>所以 <code>long long</code> 在转为 <code>double</code> 时会损失不少精度</p><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>想起以前很多时候，觉得一个库函数好用就天天拿来玩，却没有去想其功能与使用范围。导致埋下了不少坑。</p><h3 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt"></a>sqrt</h3><p>就我个人而言，最易出问题的当数 <code>sqrt</code> 函数</p><p>很多人都知道这个函数是求一个数的根，但是却没有去看其返回类型以及传入类型</p><p>查看cmath库的定义源码</p><p><img src="https://raw.githubusercontent.com/caiddd/picture/main/20221008154023.png"></p><p>可见除 <code>float</code>，<code>long double</code>类型外，其余均返回 <code>double</code></p><p>其中</p><p><img src="https://raw.githubusercontent.com/caiddd/picture/main/20221008155005.png"></p><p><code>float</code> 另调用 <code>math.h</code> 的 <code>sqrtf</code> 函数</p><p><code>long double</code> 另调用 <code>math.h</code> 的 <code>sqrtl</code> 函数</p><p>其他类型则调用 <code>math.h</code> 的 <code>sqrt</code> 函数</p><p>该函数在C库仅有如下声明</p><p><img src="https://raw.githubusercontent.com/caiddd/picture/main/20221008155245.png"></p><p>故整型均会强转为 <code>double</code> 进行运算，<code>long long</code> 便是在此处传入时损失了精度。若想不损失精度，要么传入的时候强转为<code>long double</code> ，要么调用C库的 <code>sqrtl</code> 函数。</p><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><p>后续又对许多数学库函数进行了观察，发现很多库函数都对 <code>float</code> ,<code>long double</code> 进行了单独处理，对于 <code>float</code> 函数名基本都为常见的那个后面加个<code>f</code>，对于 <code>float</code> 函数名基本都为常见的那个后面加个<code>l</code>。数学库的函数大部分都是返回 <code>double</code> 型，而非整型。初学者往往会将 <code>pow</code>，<code>ceil</code> 误当作返回整型的函数，一定要注意精度的损失。</p><p>顺带一提，这些数学库函数的复杂度基本都是可以当作 $O(1)$ 的，只是常数比较大，其底层有用到类似牛顿迭代法一类的数学加速方法。</p><h2 id="算法上避免精度误差"><a href="#算法上避免精度误差" class="headerlink" title="算法上避免精度误差"></a>算法上避免精度误差</h2><p>避免除法取根号等运算，不仅可以在精度上提升，还可以提快速度。我曾经就有因为除法而在一道题上超时。</p><p>替换方法举例：</p><p>如将</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>替换为</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">*</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">dis</span><span class="token punctuation">(</span><span class="token keyword">int</span> ax<span class="token punctuation">,</span> <span class="token keyword">int</span> ay<span class="token punctuation">,</span> <span class="token keyword">int</span> bx<span class="token punctuation">,</span> <span class="token keyword">int</span> by<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">p2</span><span class="token punctuation">(</span>ax <span class="token operator">-</span> ay<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">p2</span><span class="token punctuation">(</span>bx <span class="token operator">-</span> by<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>替换为</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dis</span><span class="token punctuation">(</span><span class="token keyword">int</span> ax<span class="token punctuation">,</span> <span class="token keyword">int</span> ay<span class="token punctuation">,</span> <span class="token keyword">int</span> bx<span class="token punctuation">,</span> <span class="token keyword">int</span> by<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">p2</span><span class="token punctuation">(</span>ax <span class="token operator">-</span> ay<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">p2</span><span class="token punctuation">(</span>bx <span class="token operator">-</span> by<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>并直接使用整数比较距离远近，只在结果输出时对其进行特殊处理。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常数优化技巧</title>
      <link href="/cpp-chang-shu-you-hua-ji-qiao/"/>
      <url>/cpp-chang-shu-you-hua-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>下面这三行代码加到C++的开头，有些情况可以对代码运行速度有显著的提升<br>一般来说，代码结构越简单，这三行代码优化得越多</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">GCC <span class="token function">target</span> <span class="token punctuation">(</span></span><span class="token string">"avx2"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">GCC <span class="token function">optimization</span> <span class="token punctuation">(</span></span><span class="token string">"O3"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">GCC <span class="token function">optimization</span> <span class="token punctuation">(</span></span><span class="token string">"unroll-loops"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>料理制作</title>
      <link href="/liao-li-zhi-zuo/"/>
      <url>/liao-li-zhi-zuo/</url>
      
        <content type="html"><![CDATA[<p>本文持续更新，内容主要是单人料理，量也基本都按一个人来</p><h2 id="基本刀法"><a href="#基本刀法" class="headerlink" title="基本刀法"></a>基本刀法</h2><ol><li>连续快刀纵切，主要是蔬菜类</li><li>慢刀斜切，一定要厚度均匀，刀与砧板成70度左右即可，不要太斜。该法主要为增大接触面积，针对肉类</li><li>双刀暴切，做肉末，蒜蓉等</li><li>对角线切加纵切，主要针对方块类食材，如水豆腐块。方法是先沿方块对角线切两刀，分成四个等腰三角形柱体。再把四个柱体沿高纵切，即可得到许多三角形的扁豆腐，形状好看也入味。</li><li>花切，对于食材连续切了很多刀，但是每刀都没到底，切完还是一个整体。如果是豆腐，这样切好后放水里可以变成一朵花，但是不会散。等以后一定学会。</li></ol><h2 id="烹饪方式"><a href="#烹饪方式" class="headerlink" title="烹饪方式"></a>烹饪方式</h2><h3 id="煮"><a href="#煮" class="headerlink" title="煮"></a>煮</h3><h4 id="饺子"><a href="#饺子" class="headerlink" title="饺子"></a>饺子</h4><p>锅内加<strong>冷水</strong>，等水热后下料，在下料后到水饺浮于水面的时间里，不断用漏网捞底，防止水饺粘锅，加热到浮起后不用再管</p><p>冒泡后，加瓢冷水，继续煮至冒泡，再加水，如此反复，中途需使水线始终高于锅底火碰到的最高线，这是防止烧锅，还要高于水饺的高度，使其不碰底，避免粘锅</p><p>反复加水直到试吃时已经完全熟透</p><p>饺子一般需要加三次冷水，如此操作是防止沸腾的热水煮破面皮，使得里面的精华流出。一般煮破的水饺都不太好吃，因为味道都散到水里去了</p><h4 id="面条粉条"><a href="#面条粉条" class="headerlink" title="面条粉条"></a>面条粉条</h4><p>和饺子差不多，不过一般加一次冷水就好了</p><h3 id="蒸"><a href="#蒸" class="headerlink" title="蒸"></a>蒸</h3><h4 id="没有蒸锅"><a href="#没有蒸锅" class="headerlink" title="没有蒸锅"></a>没有蒸锅</h4><p>这是常遇到的情况，可以用一般锅子加小铁架代替，底下加适量水，最好是保持水线在火线之上，防烧锅，这种方法一般就蒸点剩饭剩菜之类的，大概十几分钟就ok了。</p><h4 id="有蒸锅"><a href="#有蒸锅" class="headerlink" title="有蒸锅"></a>有蒸锅</h4><p>加水，放其架子上直接无脑蒸即可</p><p>蒸这种方式没太多可操作性，主要小技巧在于控水，就是在底下的蒸水里放东西，比如一些香料，使其香味沿着水汽透到食材里，更加香。</p><h3 id="炒"><a href="#炒" class="headerlink" title="炒"></a>炒</h3><h4 id="大火爆炒"><a href="#大火爆炒" class="headerlink" title="大火爆炒"></a>大火爆炒</h4><p>所有烹饪方式里最具技巧性的方式，目前就会无脑翻炒，不粘锅就算成功。争取以后学会颠锅。</p><h4 id="小火慢炒"><a href="#小火慢炒" class="headerlink" title="小火慢炒"></a>小火慢炒</h4><p>新手就别学老手搞大火爆炒了，最近发现蛋炒饭我小火慢炒反而好吃些。</p><h2 id="面条汤底"><a href="#面条汤底" class="headerlink" title="面条汤底"></a>面条汤底</h2><p>基本原料：小葱，大蒜，香菜，小米辣</p><p>刀法1：葱，香菜，小米辣</p><p>拍烂+刀法3：大蒜</p><p>如果有时间可以用油炸一下蒜蓉，表面微微发黄即可，这样更香，炸完的油还可以取一些浇到之后的汤底上</p><h3 id="香辣汤底"><a href="#香辣汤底" class="headerlink" title="香辣汤底"></a>香辣汤底</h3><p>蒜蓉 + 葱花 + 小米辣 + 辣椒面（没有的用老干妈也行）+ 白芝麻（没有可以不放）+</p><p>之前的蒜油 + 一小勺生抽 + 一小勺香醋 + 适量盐 + 少许白糖（可不放）</p><p>该汤底还可当作饺子的蘸料</p><h3 id="麻汁汤底"><a href="#麻汁汤底" class="headerlink" title="麻汁汤底"></a>麻汁汤底</h3><p>一小勺芝麻香油 + 两小勺芝麻酱 + 两小勺生抽 + 一小勺香醋 + 白芝麻 + 榨菜 + 香菜 + 葱花</p><h3 id="清汤汤底"><a href="#清汤汤底" class="headerlink" title="清汤汤底"></a>清汤汤底</h3><p>盐 + 鸡精（几粒就行）+ 少许白糖 + 一小勺生抽 + 一小勺香醋 + 芝麻香油 + 葱花</p><h2 id="蛋炒饭"><a href="#蛋炒饭" class="headerlink" title="蛋炒饭"></a>蛋炒饭</h2><p>原料：鸡蛋，隔夜饭（颗粒感强），老干妈，葱花</p><p>注：技术不行建议用小火慢炒</p><ul><li>将鸡蛋打散，一般两个就够了</li><li>植物油润锅，猪油或者老干妈辣油下锅</li><li>油热后放打散的鸡蛋，搅散就可以了</li><li>接着放剩饭，放之前可以用手捏散，好炒些</li><li>放盐，放<strong>老抽</strong>，炒一分钟左右</li><li>再放葱花，炒个两到三分钟，香味满溢就可以收锅了</li></ul><p>蛋炒饭可扩展性非常强，可以加香肠，萝卜，香菇，玉米等一起炒。但是一定要注意，放入蛋炒饭里的食材尽量都切成颗粒状，口感才统一。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 做饭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo公式渲染问题</title>
      <link href="/hexo-gong-shi-xuan-ran-wen-ti/"/>
      <url>/hexo-gong-shi-xuan-ran-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="不能渲染的公式"><a href="#不能渲染的公式" class="headerlink" title="不能渲染的公式"></a>不能渲染的公式</h2><p>hexo下自带的markdown不能渲染如下公式</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">\exist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="行内公式显示"><a href="#行内公式显示" class="headerlink" title="行内公式显示"></a>行内公式显示</h2><p>如果要支持行内公式，需要将</p><p><code>node_modules\marked\lib\marked.ejs</code></p><p>中的</p><p><code>escape:</code> 换成</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">escape<span class="token operator">:</span> /^\\(<span class="token punctuation">[</span>`*\<span class="token punctuation">[</span>\<span class="token punctuation">]</span>()#$+\-.!_&gt;<span class="token punctuation">]</span>)/<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>em:</code> 换成</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">em<span class="token operator">:</span> /^\*((?<span class="token operator">:</span>\*\*|<span class="token punctuation">[</span>\s\S<span class="token punctuation">]</span>)+?)\*(?!\*)/<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意这样处理后，如果公式出现两个连续的{，中间要加空格</p><h2 id="公式换行问题"><a href="#公式换行问题" class="headerlink" title="公式换行问题"></a>公式换行问题</h2><p>如果在公式块中打 <code>\\</code> 来换行，如果是纯markdown就没问题，但是hexo会带入前端渲染，这个会被解析成一个 <code>\</code>，所以需要打四个 <code>\\\\</code>，就可以成功换行了</p>]]></content>
      
      
      <categories>
          
          <category> 博客问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022CCPC江苏省赛</title>
      <link href="/2022ccpc-jiang-su-sheng-sai/"/>
      <url>/2022ccpc-jiang-su-sheng-sai/</url>
      
        <content type="html"><![CDATA[<p>只记录写了的题</p><h2 id="A-PENTA-KILL"><a href="#A-PENTA-KILL" class="headerlink" title="A  PENTA KILL!"></a>A  <a href="https://codeforces.com/gym/103743/problem/A">PENTA KILL!</a></h2><p>签到题，主要难点在于读题…</p><p>如果你玩moba类游戏，会觉得他这个题意十分别扭，听说有个省赛金牌爷这题开局错了五发</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> m<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>string u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> u <span class="token operator">&gt;&gt;</span> v<span class="token punctuation">;</span>m<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span>_<span class="token punctuation">,</span> s<span class="token punctuation">]</span> <span class="token operator">:</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"PENTA KILL!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SAD:("</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Jump-and-Treasure"><a href="#C-Jump-and-Treasure" class="headerlink" title="C Jump and Treasure"></a>C <a href="https://codeforces.com/gym/103743/problem/C">Jump and Treasure</a></h2><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>有个调皮的小朋友在数轴的柱子上往正方向跳，一开始在 $ 0 $ ，有 $n(1 \le n \le 10^6)$ 个柱子可以跳，分别位于 $1,2,3,\dots,n$ ，跳的距离不能超过 $p(2 \le p \le 10^6)$，每个柱子的权值为 $a_{i} (-10^9 \le a_{i} \le 10^9)$。有 $q(1 \le q \le 10^6)$ 次询问，每次询问给定一个数 $x$ ，限定跳的距离只能是 $x(1 \le x \le n)$ 的倍数，跳到  $[n+1,+\infty)$ 即视为游戏胜利。对每次询问，如果能胜利，求跳的柱子权值和最大值，否则输出 $Noob$ 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>易知不用管大于p的跳跃距离。如果对剩下的每种跳跃距离枚举，找到每种距离能跳的所有柱子，符合调和级数复杂度，为 $O(nlogn)$。对每个距离找到的柱子进行动态规划，易列出转移式<br>$$<br>dp[i] =  max_{i−j \le p}(dp[j]) + a[i]<br>$$<br>然后这就是单调队列的经典运用了，注意空间优化，毕竟是用 $long \; long$ 存的，输入输出也注意优化，因为已经到了百万级了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> ll <span class="token operator">=</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e6</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>ll ans<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> q<span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fill</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> ans <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> LLONG_MIN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> p<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>ll<span class="token operator">&gt;</span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">/</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> LLONG_MIN<span class="token punctuation">)</span><span class="token punctuation">;</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">,</span> <span class="token operator">++</span>cnt<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">-</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> i <span class="token operator">&gt;</span> p<span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> p <span class="token operator">&gt;</span> n<span class="token punctuation">)</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> dp<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> q<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> p<span class="token punctuation">)</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> ans<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Noob\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="I-Cutting-Suffix"><a href="#I-Cutting-Suffix" class="headerlink" title="I Cutting Suffix"></a>I <a href="https://codeforces.com/gym/103743/problem/I">Cutting Suffix</a></h2><h3 id="大意-1"><a href="#大意-1" class="headerlink" title="大意"></a>大意</h3><p>给定一个字符串，将其所有后缀字符串分为两个集合，使得集合一的每个字符串与集合二的每个字符串两两之间最长公共前缀长度之和最小</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果该字符串不是只有一个字符，那么总可以按后缀字符串的首字母拆成两个集合，两个集合里的字符串两两公共前缀长度均为 $0$ ，总和为 $0$ 。如果该字符串只有一个字符，那么将长度为 $1$ 的后缀字符串单独划为一个集合，其他在另一个集合，总和即为原字符串长度减 $1$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string s<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">;</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="J-Balanced-Tree"><a href="#J-Balanced-Tree" class="headerlink" title="J Balanced Tree"></a>J <a href="https://codeforces.com/gym/103743/problem/J">Balanced Tree</a></h2><h3 id="大意-2"><a href="#大意-2" class="headerlink" title="大意"></a>大意</h3><p>$T(1 \le T \le 10^6)$ 组测试数据，每组给一个数 $n(0 \le n \lt 2^{64})$ ，求节点数为 $n$ 的超级平衡二叉树数量，答案模$2^{64}$ 。如果一棵树为空树，或者左子树节点数和右子树节点数之差小于等于 $1$ ，则为超级平衡二叉树。对此题特别提一下空间只给了 $64MB$ ，时限是 $1.5s$ 。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>很容易想到下面的递归式。<br>$$<br>f[0]=1 \\\<br>f[x]=<br>\begin{cases}<br>2f[\frac{x}{2}]f[\frac{x}{2}-1],\quad x 为偶数 \\\<br>f[\frac{x-1}{2}]^2,\quad x为奇数<br>\end{cases}<br>$$<br>加上哈希就成了记忆化搜索，使用C++的unsigned long long自然溢出取模，代码如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> R <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>R n<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%llu"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>unordered_map<span class="token operator">&lt;</span>R<span class="token punctuation">,</span> R<span class="token operator">&gt;</span> m<span class="token punctuation">;</span>m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>function<span class="token operator">&lt;</span><span class="token function">R</span><span class="token punctuation">(</span>R<span class="token punctuation">)</span><span class="token operator">&gt;</span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span>R x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> m<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>R les <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span>m<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>les<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">dfs</span><span class="token punctuation">(</span>les <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">else</span>m<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>les<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">dfs</span><span class="token punctuation">(</span>les<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> m<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%llu\n"</span><span class="token punctuation">,</span> <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> t<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span><span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>懒得算复杂度了，直接交，果然超时。如果把容器和函数移到solve外面，那么就超空间。</p><p>考虑优化，由递归式可以看出结果为2的幂，要是能直接得到幂就好解了，幂大于等于64的结果为0，其他的输出结果即可</p><p>为了得到幂，进行取对数操作<br>$$<br>设\; g[x]=\log_{2}{f[x]}，有\\\<br>g[0]=0\\\<br>g[x]=<br>\begin{cases}<br>g[\frac{x}{2}]+g[\frac{x}{2}-1]+1,\quad x 为偶数\\\<br>2g[\frac{x-1}{2}],\quad x为奇数<br>\end{cases}\\\<br>由上易知\;\forall n \in N,存在\; x \in N^{*},\;g[n]=a \cdot g[x]+b \cdot g[x-1]+c\\\<br>化为\;g[n]=<br>\begin{cases}<br>a \cdot (g[\frac{x}{2}] + g[\frac{x}{2} − 1] + 1) + b \cdot (2g[\frac{x-1-1}{2}]) + c,\quad x是偶数\\\<br>a \cdot (2g[\frac{x-1}{2}]) + b \cdot (g[\frac{x-1}{2}] + g[\frac{x-1}{2} − 1] + 1) + c,\quad x是奇数<br>\end{cases}\\\<br>=<br>\begin{cases}<br>a \cdot g[\frac{x}{2}] + (a+2b) \cdot g[\frac{x}{2}-1] + c + a,\quad x是偶数\\\<br>(2a+b) \cdot g[\frac{x-1}{2}] + b \cdot g[\frac{x-1}{2}-1] + c + b,\quad x是奇数<br>\end{cases}\\\<br>于是初始\;g[n]=1\cdot g[n] + 0 \cdot g[n-1] + 0\\\<br>不断除二直到\;n = 1,化为\\\<br>g[n] = a\cdot g[1] + b \cdot g[0] + c=c<br>$$<br>最后只需要对 $c$  进行前文提到的判断即可得到答案</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> R <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>R n<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%llu"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>R a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span>a <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">,</span> a <span class="token operator">+=</span> b<span class="token punctuation">,</span> c <span class="token operator">+=</span> b<span class="token punctuation">;</span><span class="token keyword">else</span>b <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">+=</span> a<span class="token punctuation">,</span> c <span class="token operator">+=</span> a<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&gt;=</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>n <span class="token operator">&gt;&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%llu\n"</span><span class="token punctuation">,</span> <span class="token number">1ull</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> t<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span><span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里记录一个坑点，C++编译器种类实在太多了。。。你任何不规范的操作都有可能导致在不同编译器下结果不同，在此题中，之前犯的错误是忽略了编译器的警告，这样进行输出 <code>printf("%llu\n", 0);</code> ，在有些编译器下不一定输出0，而是一个很大的整数，除非在格式化输出前对 $0$ 进行强转，转为unsigned long long</p><h2 id="K-aaaaaaaaaaA-heH-heH-nuN"><a href="#K-aaaaaaaaaaA-heH-heH-nuN" class="headerlink" title="K aaaaaaaaaaA heH heH nuN"></a>K <a href="https://codeforces.com/gym/103743/problem/K">aaaaaaaaaaA heH heH nuN</a></h2><h3 id="大意-3"><a href="#大意-3" class="headerlink" title="大意"></a>大意</h3><p>$T(1\le T \le 1000)$ 组测试数据，每组给出一个数 $n (0 \le n \le 10^9)$ ，构造一个字符串，其所有子序列中，优雅字符串的数量为 $n$。优雅字符串的定义是，前缀为 $ nunhehheh $ ，后缀为任意非零数量的 $a$ 。且你输出的所有字符串长度总和不超过 $10^6$</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>该题有点反动态规划的感觉，通过答案来构造。一般这种数据范围这么大的，都是有指数级构造法的。很容易想到如果在  $ nunhehhe $ 后面，加上 $n$ 个 $h$ ，最后加上个 $a$ ，总能构造出所有的值。但由于输出长度限制不能这么做。</p><p>要指数级只能从 $a$ 的个数下手，容易发现 $nunhehheh\underbrace{a\dots a}_{x个}$ 这种形式符合要求的子序列有 $2^x-1$ 个，于是就可以从大到小枚举 $x$ ，$n$ 大于等于 $2^x -1$ 就减去，添加 $h$ </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>string ans <span class="token operator">=</span> <span class="token string">"nunhehhe"</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>ans <span class="token operator">+=</span> <span class="token char">'a'</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ans <span class="token operator">+=</span> <span class="token char">'h'</span><span class="token punctuation">;</span>n <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>ans <span class="token operator">+=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> t<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> t<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span><span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="L-Collecting-Diamonds"><a href="#L-Collecting-Diamonds" class="headerlink" title="L Collecting Diamonds"></a>L <a href="https://codeforces.com/gym/103743/problem/L">Collecting Diamonds</a></h2><h3 id="大意-4"><a href="#大意-4" class="headerlink" title="大意"></a>大意</h3><p>给你一个由字符 $A,B,C$  构成的字符串，长度小于 $2 \cdot 10^5$，每个字符的下标为 $1,2,3,\dots,n$ 。如果子串有 $ABC$  ，则可以进行操作，$A$ 为奇数下标则取走该子串的$A,C$，为偶数下标则取走 $B$ ，该字符串剩下的字符顺次拼接，并重新划定下标。问最多能够进行多少次操作。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>首先易见，两种操作中，只有取走 $A,C$ 才可以连续操作，同时该操作不会改变后面下标的奇偶性。只有取走 $B$，才会改变。</p><p>同时，我们可以发现每个类似 $AAA\dots ABC \dots CCC$ 的子串都相对独立，即对该子串进行操作，不会影响其他这类子串的字符数量，于是每次找到 $B$ 可以左右找 $A,C$，将原字符串划分。</p><p>还有，取走 $B$ 对上述划分后的子串，最多只能进行一次。我们为了能对后面进行更灵活的操作，肯定是尽可能让前面的子串都进行一次取 $B$ 的操作</p><p>于是我们可以用一个变量暂存前面取 $B$ 操作的次数，计算每个子串最多能删除多少次 $A,C$ </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string s<span class="token punctuation">;</span>cin <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">;</span><span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'B'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> l <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">and</span> r <span class="token operator">&lt;</span> n <span class="token operator">and</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'A'</span> <span class="token operator">and</span> s<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'C'</span><span class="token punctuation">)</span><span class="token operator">--</span>l<span class="token punctuation">,</span> <span class="token operator">++</span>r<span class="token punctuation">,</span> <span class="token operator">++</span>cnt<span class="token punctuation">;</span><span class="token operator">++</span>l<span class="token punctuation">,</span> <span class="token operator">--</span>r<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tot<span class="token punctuation">)</span><span class="token operator">++</span>tot<span class="token punctuation">;</span>ans <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>ans <span class="token operator">+=</span> <span class="token function">min</span><span class="token punctuation">(</span>tot<span class="token punctuation">,</span> cnt <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token operator">++</span>tot<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>ans <span class="token operator">+=</span> <span class="token function">min</span><span class="token punctuation">(</span>tot<span class="token punctuation">,</span> cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">++</span>tot<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 程序设计竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCPC </tag>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/test/"/>
      <url>/test/</url>
      
        <content type="html"><![CDATA[<h1 id="公式测试"><a href="#公式测试" class="headerlink" title="公式测试"></a>公式测试</h1><p>$O(n^2)$<br>$$<br>ans = \sum_{1}^n \sqrt{\frac{4ac-b^2}{2a}}<br>$$</p><h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h1><p>注：在hexo框架下，markdown标示c++语言需要写成cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>    cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">+</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="表情测试"><a href="#表情测试" class="headerlink" title="表情测试"></a>表情测试</h1><p>😆</p>]]></content>
      
      
      <categories>
          
          <category> 博客问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
